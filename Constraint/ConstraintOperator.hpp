/**
 * @file ConstraintOperator.hpp
 * @author Wen Yan (wenyan4work@gmail.com)
 * @brief
 * @version 0.1
 * @date 2019-10-17
 *
 * @copyright Copyright (c) 2019
 *
 */
#ifndef CONSTRAINTOPERATOR_HPP_
#define CONSTRAINTOPERATOR_HPP_

#include "Trilinos/TpetraUtil.hpp"

#include <array>
#include <deque>
#include <vector>

/**
 * @brief Constraint Operator is a block matrix assembled from four blocks:
 *    [Dc^T M Dc       Dc^T M Db           ]
 *    [Db^T M Dc       Db^T M Db  +  K^{-1}]
 *
 * Dc^T, Db^T, M, and K^{-1} are explicitly constructed before constructing this object
 */
class ConstraintOperator : public TOP {
  public:
    /**
     * @brief Construct a new ConstraintOperator object
     *
     * @param mobOp
     * @param uniDcMat
     * @param biDbMat
     * @param invKappaDiagMat
     */
    ConstraintOperator(Teuchos::RCP<TOP> &mobOp, Teuchos::RCP<TCMAT> &uniDcMatTrans, Teuchos::RCP<TCMAT> &biDbMatTrans,
                       std::vector<double> &invKappaDiagMat);

    /**
     * @brief apply this operator, ensuring the block structure
     *
     * @param X
     * @param Y
     * @param mode if the operator should be applied as transposed
     * @param alpha
     * @param beta
     */
    void apply(const TMV &X, TMV &Y, Teuchos::ETransp mode = Teuchos::NO_TRANS,
               scalar_type alpha = Teuchos::ScalarTraits<scalar_type>::one(),
               scalar_type beta = Teuchos::ScalarTraits<scalar_type>::zero()) const;

    /**
     * @brief Get the Domain Map object. interface required by Tpetra::Operator
     *
     * @return Teuchos::RCP<const TMAP>
     */
    Teuchos::RCP<const TMAP> getDomainMap() const;

    /**
     * @brief Get the Range Map object. interface required by Tpetra::Operator
     *
     * @return Teuchos::RCP<const TMAP>
     */
    Teuchos::RCP<const TMAP> getRangeMap() const;

    /**
     * @brief return if this operator can be applied as transposed. interface required by Tpetra::Operator
     *
     * @return true
     * @return false
     */
    bool hasTransposeApply() const { return false; }

  private:
    // comm
    Teuchos::RCP<TCOMM> commRcp; ///< the mpi communicator
    // constant operators
    Teuchos::RCP<TOP> mobOpRcp;           ///< mobility matrix
    Teuchos::RCP<TCMAT> uniDcMatRcp;      ///< unilateral (collision) constraint geometry matrix D_c
    Teuchos::RCP<TCMAT> uniDcMatTransRcp; ///< explicit transpose of D_c
    Teuchos::RCP<TCMAT> biDbMatRcp;       ///< bilateral (spring) constraint geometry matrix D_b
    Teuchos::RCP<TCMAT> biDbMatTransRcp;  ///< explicit transpose of D_b
    std::vector<double> invKappaDiagMat;  ///< 1/h K^{-1} diagonal matrix, in std::vector format

    // maps
    Teuchos::RCP<TMAP> mobMapRcp;           ///< map for mobility matrix. 6 DOF per obj
    Teuchos::RCP<TMAP> gammaMapRcp;         ///< map for BOTH gamma c and gamma b
    Teuchos::RCP<TMAP> gammaUniBlockMapRcp; ///< map for the rows in gammaMapRcp for the uni blocks
    Teuchos::RCP<TMAP> gammaBiBlockMapRcp;  ///< map for the rows in gammaMapRcp for the bi blocks

    // working multivectors with 4 columns
    Teuchos::RCP<TMV> gammaForceRcp;  ///< force & torque vectors generated by constraint forces
    Teuchos::RCP<TMV> mobVelRcp;      ///< U & Omega vectors generated by constraint forces
    Teuchos::RCP<TMV> deltaUniRcp; ///< changes in constraint vectors due to unilateral constraint forces
    Teuchos::RCP<TMV> deltaBiRcp;  ///< changes in constraint vectors due to bilateral constraint forces

    /**
     * @brief build block maps with map1 and map2
     * assuming both map1 and map2 are contiguous and start from 0-indexbase
     * assuming map1=[0,1,2 | 3,4,5]
     *          map2=[0,1 | 2]
     * new global map = [0,1,2,6,7 | 3,4,5,8]
     * where 0,1,2,3,4,5 are from map1, and 6,7,8 are from 0,1,2 in map2
     * new submap1 = map1 = [0,1,2 | 3,4,5]
     * new submap2 = [6,7 | 8]
     */
    void buildBlockMaps();
};

#endif