#ifndef SYLINDERSYSTEM_HPP_
#define SYLINDERSYSTEM_HPP_

#include "Sylinder.hpp"
#include "SylinderConfig.hpp"
#include "SylinderNear.hpp"

#include "Collision/CollisionSolver.hpp"
#include "MPI/FDPS/particle_simulator.hpp"
#include "Trilinos/TpetraUtil.hpp"
#include "Util/TRngPool.hpp"

#include <memory>

class SylinderSystem {
    int snapID;
    int stepCount; // timestep Count

    // FDPS stuff
    PS::DomainInfo dinfo;
    void setDomainInfo();

    PS::ParticleSystem<Sylinder> sylinderContainer; // sylinders
    std::unique_ptr<TreeSylinderNear> treeSylinderNearPtr;
    int treeSylinderNumber;
    void setTreeSylinder();

    // Collision stuff
    std::shared_ptr<CollisionSolver> collisionSolverPtr;
    std::shared_ptr<CollisionCollector> collisionCollectorPtr;
    // Non Brownian force & velocity, set by user
    Teuchos::RCP<TV> forceNonBrownRcp;
    Teuchos::RCP<TV> velocityNonBrownRcp;
    // Brownian velocity, generated by calcBrown
    Teuchos::RCP<TV> velocityBrownRcp;
    // used in collision solver
    Teuchos::RCP<TV> velocityKnownRcp;
    Teuchos::RCP<TV> forceColRcp;
    Teuchos::RCP<TV> velocityColRcp;

    // MPI stuff
    std::shared_ptr<TRngPool> rngPoolPtr;      // thread safe rng
    Teuchos::RCP<const TCOMM> commRcp;         // mpi communicator
    Teuchos::RCP<TMAP> sylinderMapRcp;         // 1 dof per sylinder
    Teuchos::RCP<TMAP> sylinderMobilityMapRcp; // 6 dof per sylinder
    void updateSylinderMap();                  // update sylindermap and sylinderMobilityMap

    Teuchos::RCP<TCMAT> mobilityMatrixRcp; // block-diagonal mobility matrix
    Teuchos::RCP<TOP> mobilityOperatorRcp; // full mobility operator (matrix-free)

    // internal utility functions
    void setInitialFromConfig();
    void setInitialFromFile(const std::string &filename);
    void setInitialCircularCrossSection();
    void showOnScreenRank0();
    void writeVTK(const std::string &baseFolder);
    void writeAscii(const std::string &baseFolder);
    void setPosWithWall(); // directly set the position of sylinders according to wall
    std::pair<int, int> getMaxGid();
    void getOrient(Equatn &orient, const double px, const double py, const double pz, const int threadId);
    void getRandPointInCircle(const double &radius, double &x, double &y, const int &threadId);
    void fitInPeriodicBound(double &x, const double &lb, const double &ub) const;

  public:
    const SylinderConfig runConfig;

    SylinderSystem(const std::string &configFile, const std::string &posFile, int argc, char **argv);
    SylinderSystem(const SylinderConfig &config, const std::string &posFile, int argc, char **argv);
    ~SylinderSystem() = default;
    // forbid copy
    SylinderSystem(const SylinderSystem &) = delete;
    SylinderSystem &operator=(const SylinderSystem &) = delete;

    void calcDomainDecomp(); // domain decomposition must be triggered when particle distribution significantly changes
    void exchangeSylinder(); // particle exchange must be triggered every timestep:

    void getBoundingBox(Evec3 &localLow, Evec3 &localHigh, Evec3 &globalLow, Evec3 &globalHigh);

    // one-step high level API
    PS::ParticleSystem<Sylinder> &getContainer() { return sylinderContainer; }
    PS::DomainInfo &getDomainInfo() { return dinfo; }
    // between prepareStep() and runStep(), sylinders should not be moved, added, or removed
    void prepareStep();
    void setForceNonBrown(const std::vector<double> &forceNonBrown);
    void setVelocityNonBrown(const std::vector<double> &velNonBrown);
    void runStep();
    // These should run after runStep()
    void addNewSylinder(std::vector<Sylinder> &newSylinder); // add new particles and assign new (unique) gid
    void calcColStress();                                    // calc collision stress
    void calcVolFrac();                                      // calc volume fraction

    // detailed low level API
    void applyBoxBC();
    void calcVelocityBrown(); // write back to sylinder.velBrown
    void calcVelocityKnown(); // write back to sylinder.velNonB before adding velBrown
    Teuchos::RCP<TV> getForceNonBrown() const { return forceNonBrownRcp; }
    Teuchos::RCP<TV> getVelocityNonBrown() const { return velocityKnownRcp; };
    Teuchos::RCP<TV> getVelocityBrown() const { return velocityBrownRcp; };
    Teuchos::RCP<TV> getVelocityKnown() const { return velocityKnownRcp; };
    Teuchos::RCP<TV> getForceCol() const { return forceColRcp; };
    Teuchos::RCP<TV> getVelocityCol() const { return velocityColRcp; };

    void collectWallCollision();  // collect wall collision constraints
    void collectPairCollision();  // collect pair collision constraints
    void resolveCollision();      // resolve collision
    void saveVelocityCollision(); // write back to sylinder.velCol

    void calcMobMatrix();
    void calcMobOperator();
    Teuchos::RCP<TCMAT> getMobMatrix() { return mobilityMatrixRcp; };
    Teuchos::RCP<TOP> getMobOperator() { return mobilityOperatorRcp; };

    // IO
    std::string getCurrentResultFolder();
    bool writeResultCurrentStep();
    void writeResult();

    void stepEuler(); // Euler step update position and orientation, with given velocity
};

#endif