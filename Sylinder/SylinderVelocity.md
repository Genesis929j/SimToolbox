## Definition

Each sylinder's total force, torque, velocity, and angular velocity are defined in the `Sylinder` class as these members:

```cpp
double force[3]
double torque[3]
double vel[3]
double omega[3]
```

The velocity and omega contain the following components:

```cpp
vel = velCol+velBi+velNonB+velBrown
omega = omegaCol+omegaBi+omegaNonB+omegaBrown
```

The force and torque contain the same components except the Brownian ones, because Brownian motion is calculated directly as displacements without computing forces.

```cpp
force = forceCol+forceBi+forceNonB
torque = torqueCol+torqueBi+torqueNonB
```

Here, `Col` is collisions, `Bi` is bilateral constraints, `Brown` is Brownian motion, `NonB` is all Non-Brownian components before constraint solver is supplied.
Each step contains the following steps:

1. `velBrown` and `omegaBrown` are calculated.
2. `velNonB` and `omegaNonB` are calculated.
3. `velBrown+velNonB` and `omegaBrown+omegaNonB` are passed to the constraint solver, and `velCol`, `omegaCol`, `velBi` and `omegaBi` are calculated. `forceCol`, `torqueCol`, `forceBi`, and `torqueBi` are simultaneously calculated by the constraint solver.

## Interface in `SylinderSystem` class

Unless you really have to, do not directly modify the member data files in the container of Sylinders. Instead, use the following interface that are exposed by the `SylinderSystem` class.

### Brownian

`velBrown` and `omegaBrown` are computed by the member function `void calcVelocityBrown();`

### NonBrownian

These are called `NonBrownian` but they actually contain everything not calculated by `calcVelocityBrown()` and also not computed by constraint resolution.
The `NonBrownian` components are separated to two parts, and are summed up in the member function `void calcVelocityNonCon()`:

1. directly specified as velocity and angular velocity. This part should be specified by the member function `void setVelocityNonBrown(const std::vector<double> &velNonBrown);`.
2. specified as imposed force and torque, and then mobility matrix is applied to compute velocity and angular velocity. This part should be specified by the member function `void setForceNonBrown(const std::vector<double> &forceNonBrown);`

When the two parts have all been specified, the member function `void calcVelocityNonCon()` sums up everything and write the results back to member variables to each `Sylinder` class

1. `Sylinder::velBrown` and `Sylinder::omegaBrown` are directly computed as in `calcVelocityBrown()`.
2. `Sylidner::velNonB` and `Sylinder::omegaNonB` contains what is specified in `setVelocityNonBrown(const std::vector<double> &velNonBrown)` **PLUS** the motion generated by `setForceNonBrown(const std::vector<double> &forceNonBrown)`.
3. `Sylinder::forceNonB` and `Sylinder::torqueNonB` contains **ONLY** the input specified by `setForceNonBrown(const std::vector<double> &forceNonBrown)`. The motion specified by `setVelocityNonBrown(const std::vector<double> &velNonBrown)` is not relevant for these two data fields, because we do not solve an inverse-mobility problem to compute the force generated by the input `velNonBrown`.

### Col and Bi

These are computed in the constraint solver, and are written back to the members of `Sylinder`s in the member function `void sumForceVelocity()`

### Total

All above components are summed up in the member function `void sumForceVelocity()`
