/**
 * @file ParticleSystem.hpp
 * @author Wen Yan (wenyan4work@gmail.com)
 * @brief
 * @version 0.1
 * @date 2021-01-25
 *
 * @copyright Copyright (c) 2021
 *
 */
#ifndef PARTICLESYSTEM_HPP_
#define PARTICLESYSTEM_HPP_

#include "SystemConfig.hpp"

#include "Boundary/Boundary.hpp"
#include "Constraint/ConstraintSolver.hpp"
#include "FDPS/particle_simulator.hpp"
#include "Trilinos/TpetraUtil.hpp"
#include "Trilinos/ZDD.hpp"
#include "Util/TRngPool.hpp"

#include <vtkCellData.h>
#include <vtkDataArray.h>
#include <vtkPointData.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkSmartPointer.h>
#include <vtkXMLPPolyDataReader.h>

template <class Ptcl>
class ParticleSystem {

    using PtclConfig = Ptcl::ParticleConfig; ///< 'Config' type for this particle
    using PtclNearEP = Ptcl::NearEP;         ///< 'essential' type for near interactions
    using PtclNearForce = Ptcl::NearForce;   ///< 'force' result for near interactions

    static_assert(std::is_trivially_copyable<Ptcl>::value, "");
    static_assert(std::is_default_constructible<Ptcl>::value, "");

    static_assert(std::is_trivially_copyable<PtclNearEP>::value, "");
    static_assert(std::is_default_constructible<PtclNearEP>::value, "");

    static_assert(std::is_trivially_copyable<PtclNearForce>::value, "");
    static_assert(std::is_default_constructible<PtclNearForce>::value, "");

    using TreeParticleNear = PS::TreeForForceShort<PtclNearForce, PtclNearEP, PtclNearEP>::Symmetry;

    bool enableTimer = false;
    int snapID;                  ///< the current id of the snapshot file to be saved. sequentially numbered from 0
    int stepCount;               ///< timestep Count. sequentially numbered from 0
    unsigned int restartRngSeed; ///< parallel seed used by restarted simulations

    // FDPS stuff
    PS::DomainInfo dinfo; ///< domain size, boundary condition, and decomposition info
    void setDomainInfo();

    PS::ParticleSystem<Ptcl> ptclContainer;                ///< particles
    std::unique_ptr<TreeParticleNear> treeParticleNearPtr; ///< short range interaction of sylinders

    int treeParticleNumber; ///< the current max_glb number of treeParticleNear
    void setTreeParticle();

    // Constraint stuff
    std::shared_ptr<ConstraintSolver> conSolverPtr;       ///< pointer to ConstraintSolver
    std::shared_ptr<ConstraintCollector> conCollectorPtr; ///<  pointer to ConstraintCollector
    Teuchos::RCP<const TV> forceUniRcp;                   ///< unilateral constraint force
    Teuchos::RCP<const TV> velocityUniRcp;                ///< unilateral constraint velocity
    Teuchos::RCP<const TV> forceBiRcp;                    ///< bilateral constraint force
    Teuchos::RCP<const TV> velocityBiRcp;                 ///< bilateral constraint velocity

    // computed without knowledge of constraints
    Teuchos::RCP<TV> forcePartNonBrownRcp;    ///< force specified by setForceNonBrown()
    Teuchos::RCP<TV> velocityPartNonBrownRcp; ///< velocity specified by setVelocityNonBrown()
    Teuchos::RCP<TV> velocityNonBrownRcp;     ///< \f$V_{NonBrown} = V_{part,NonBrown}+M F_{part,NonBrown}\f$
    Teuchos::RCP<TV> velocityBrownRcp;        ///< Brownian velocity, generated by calcBrown()
    Teuchos::RCP<TV> velocityNonConRcp;       ///< \f$V_{nc} = V_{Brown}+V_{NonBrown}\f$

    // MPI stuff
    std::shared_ptr<TRngPool> rngPoolPtr;  ///< TRngPool object for thread-safe random number generation
    Teuchos::RCP<const TCOMM> commRcp;     ///< TCOMM, set as a Teuchos::MpiComm object in constrctor
    Teuchos::RCP<TMAP> ptclMapRcp;         ///< TMAP, contiguous and sequentially ordered 1 dof per particle
    Teuchos::RCP<TMAP> ptclMobilityMapRcp; ///< TMAP, contiguous and sequentially ordered 6 dofs per particle
    Teuchos::RCP<TCMAT> mobilityMatrixRcp; ///< block-diagonal mobility matrix
    Teuchos::RCP<TOP> mobilityOperatorRcp; ///< full mobility operator (matrix-free), to be implemented

    // Data directory
    std::shared_ptr<ZDD<PtclNearEP>> ptclNearDataDirectoryPtr; ///< distributed data directory for particle data

    // internal utility functions
    /**
     * @brief generate initial configuration on rank 0 according to runConfig
     *
     */
    void setInitialFromConfig();

    /**
     * @brief set initial configuration as given in the (.dat) file
     *
     * The simBox and BC settings in runConfig are still used
     * @param filename
     */
    void setInitialFromFile(const std::string &filename);

    /**
     * @brief set initial configuration as given in the (.dat) file
     *
     * The simBox and BC settings in runConfig are still used
     * @param pvtpFileName
     */
    void setInitialFromVTKFile(const std::string &pvtpFileName);

    /**
     * @brief set initial configuration if runConfig.initCircularX is set
     *
     * This function move the position of all particles into a cylindrical tube fit in initBox
     */
    void setInitialCircularCrossSection();

    /**
     * @brief display the configuration on rank 0
     *
     */
    void showOnScreenRank0();

    /**
     * @brief update the ptclMap and ptclMobilityMap
     *
     * This function is called in prepareStep(), and no adding/removing/exchanging is allowed before runStep()
     */
    void updatePtclMap();

    /**
     * @brief write VTK parallel XML file into baseFolder
     *
     * @param baseFolder
     */
    void writeVTK(const std::string &baseFolder);

    /**
     * @brief write Ascii file controlled by FDPS into baseFolder
     *
     * @param baseFolder
     */
    void writeAscii(const std::string &baseFolder);

    /**
     * @brief write a txt file containing timestep and most recent pvtp filenames info into baseFolder
     *
     * @param baseFolder
     */
    void writeTimeStepInfo(const std::string &baseFolder);

    /**
     * @brief write a simple legacy VTK file for simBox
     *
     */
    void writeBox();

    /**
     * @brief update the rank data field of particles
     *
     */
    void updatePtclRank();

    /**
     * @brief print a message from rank 0
     *
     */
    void printRank0(const std::string &message);

    /**
     * @brief Get orientation quaternion with givne px,py,pz
     *
     * component in [px,py,pz] out of range [-1,1] will be randomly generated
     * if all out of range [-1,1], a uniformly random orientation on sphere is generated
     * @param orient
     * @param px
     * @param py
     * @param pz
     * @param threadId openmp thread id for random number generation
     */
    void getOrient(Equatn &orient, const double px, const double py, const double pz, const int threadId);

  public:
    ParticleConfig runConfig; ///< system configuration. Be careful if this is modified on the fly

    /**
     * @brief Construct a new ParticleSystem object
     *
     * initialize() should be called after this constructor
     */
    ParticleSystem() = default;

    /**
     * @brief Construct a new ParticleSystem object
     *
     * This constructor calls initialize() internally
     * @param configFile a yaml file for SystemConfig
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    ParticleSystem(const std::string &configFile, const std::string &posFile, int argc, char **argv);

    /**
     * @brief Construct a new ParticleSystem object
     *
     * This constructor calls initialize() internally
     * @param config SystemConfig object
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    ParticleSystem(const ParticleConfig &config, const std::string &posFile, int argc, char **argv);

    ~ParticleSystem() = default;

    // forbid copy
    ParticleSystem(const ParticleSystem &) = delete;
    ParticleSystem &operator=(const ParticleSystem &) = delete;

    /**
     * @brief initialize after an empty constructor
     *
     * @param config ParticleConfig object
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    void initialize(const ParticleConfig &config, const std::string &posFile, int argc, char **argv);

    /**
     * @brief reinitialize from vtk files
     *
     * @param config ParticleConfig object
     * @param restartFile txt file containing timestep and most recent pvtp file names
     * @param argc command line argument
     * @param argv command line argument
     */
    void reinitialize(const ParticleConfig &config, const std::string &restartFile, int argc, char **argv,
                      bool eulerStep = true);

    /**
     * @brief enable the timer in step()
     *
     * @param value
     */
    void setTimer(bool value) { enableTimer = value; }

    /**
     * @brief compute axis-aligned bounding box of particles
     *
     * @param localLow
     * @param localHigh
     * @param globalLow
     * @param globalHigh
     */
    void calcBoundingBox(double localLow[3], double localHigh[3], double globalLow[3], double globalHigh[3]);

    /**
     * @brief compute domain decomposition by sampling particle distribution
     *
     * domain decomposition must be triggered when particle distribution significantly changes
     */
    void decomposeDomain();

    /**
     * @brief exchange between mpi ranks according to domain decomposition
     *
     * particle exchange must be triggered every timestep:
     */
    void exchangeParticle();

    /**
     * one-step high level API
     */

    /**
     * @brief Get the Container object
     *
     * @return const PS::ParticleSystem<Ptcl>&
     */
    const PS::ParticleSystem<Ptcl> &getContainer() { return ptclContainer; }
    PS::ParticleSystem<Ptcl> &getContainerNonConst() { return ptclContainer; }

    /**
     * @brief Get the DomainInfo object
     *
     * @return PS::DomainInfo&
     */
    const PS::DomainInfo &getDomainInfo() { return dinfo; }
    PS::DomainInfo &getDomainInfoNonConst() { return dinfo; }

    /**
     * @brief Get the RngPoolPtr object
     *
     * @return std::shared_ptr<TRngPool>&
     */
    std::shared_ptr<TRngPool> &getRngPoolPtr() { return rngPoolPtr; }

    /**
     * @brief Get the CommRcp object
     *
     * @return Teuchos::RCP<const TCOMM>&
     */
    Teuchos::RCP<const TCOMM> &getCommRcp() { return commRcp; }

    /**
     * @brief prepare a step
     *
     * apply simBox boundary condition
     * decomposeDomain() for every 50 steps
     * exchangeSylinder() at every step
     * clear velocity
     * rebuild map
     * compute mobility matrix&operator
     * between prepareStep() and runStep(), sylinders should not be moved, added, or removed
     */
    void prepareStep();

    /**
     * @brief Set the (optional) forceNonBrownRcp
     *
     * This is optional.
     * this force is added to forceNonB
     * The computed mobility matrix will be applied to this force and the result is added to velNonB
     * @param forceNonBrown
     */
    void setForceNonBrown(const std::vector<double> &forceNonBrown);

    /**
     * @brief Set the (optional) velocityNonBrownRcp
     *
     * This is optional. The result is added to velNonB
     * @param velNonBrown
     */
    void setVelocityNonBrown(const std::vector<double> &velNonBrown);

    /**
     * @brief Get the Constraint Pool Non Const object
     *
     * @return ConstraintBlockPool&
     */
    ConstraintBlockPool &getConstraintPoolNonConst() { return *(conCollectorPtr->constraintPoolPtr); };

    /**
     * @brief resolve collision with given nonBrownian motion and advance the system configuration
     *
     */
    void runStep();

    // These should run after runStep()
    /**
     * @brief add new Particles into the system from all ranks
     *
     * add new particles and assign new (unique) gid
     * if no connection, set group/prev/next in linkage as GEO_INVALID_ID (as default constructor)
     * if connection, group will be set as is, prev/next will set according to new gid
     *
     * example: 2 new linked particles as group 8
     * input, linkage is specified by the order in newParticle:
     *  linkage[0]={8,GEO_INVALID_ID,1}, linkage[1]={8,0,GEO_INVALID_ID}
     * after processed by this function, linkage will be specified by the new gid assigned
     *  linkage[0]={8,GEO_INVALID_ID,newgid of newParticle[1]}, linkage[1]={8,new gid of newParticle[0],GEO_INVALID_ID}
     *
     * @param newSylinder list of new sylinders.
     * @param linkage specify linkage of new sylinders.
     *
     */
    void addNewParticle(std::vector<Ptcl> &newParticle, std::vector<Link> &linkage);

    /**
     * @brief calculate both Col and Bi stress
     *
     */
    void calcConStress();

    /**
     * @brief calculate polar and nematic order parameter
     *
     * The result is shown on screen
     */
    void calcOrderParameter();

    /**
     * @brief calculate volume fraction
     *
     */
    void calcVolFrac();

    /**
     * detailed low level API
     */
    /**
     * @brief apply periodic boundary condition
     *
     */
    void applyBoxBC();

    // compute non-collision velocity and mobility, before collision resolution
    /**
     * @brief calculate translational and rotational Brownian motion as specified in runConfig
     *
     * write back to sylinder.velBrown/omegaBrown
     */
    void calcVelocityBrown();

    /**
     * @brief calculate known velocity before collision resolution
     *
     * velocityNonCon = velocityBrown + velocityNonBrown + mobility * forceNonBrown
     * velocityNonBrown sums both the values set by setVelocityNonBrown() and directly written to
     * sylinder[i].velNonB/omegaNonB
     * write back to sylinder.velNonB/omegaNonB
     */
    void calcVelocityNonCon();

    /**
     * @brief sum vel = velNonB + velB + velCol + velBi
     *
     */
    void sumForceVelocity();

    /**
     * @brief calculate the mobility matrix (block diagonal)
     *
     */
    void calcMobMatrix();

    /**
     * @brief calculate the mobility operator (full-dense, matrix-free)
     *
     * TODO: to be implemented
     */
    void calcMobOperator();

    /**
     * @brief build the ZDD<PtclNearEP> object
     *
     */
    void buildPtclNearDataDirectory();

    /**
     * @brief Get the PtclNearDataDirectory object
     *
     * @return std::shared_ptr<const ZDD<PtclNearEP>>&
     */
    std::shared_ptr<ZDD<PtclNearEP>> &getPtclNearDataDirectory() { return ptclNearDataDirectoryPtr; }

    // resolve constraints
    void collectBoundaryCollision();     ///< collect boundary collision constraints
    void collectPairCollision();         ///< collect pair collision constraints
    void resolveConstraints();           ///< resolve constraints
    void saveForceVelocityConstraints(); ///< write back to sylinder.velCol and velBi

    void stepEuler(); ///< Euler step update position and orientation, with both collision and non-collision velocity

    // write results
    std::string getCurrentResultFolder();          ///< get the current output folder path
    std::string getResultFolderWithID(int snapID); ///< get output folder path with snapID
    bool getIfWriteResultCurrentStep();            ///< check if the current step is writing (set by runConfig)
    int getSnapID() { return snapID; };            ///< get the (sequentially ordered) ID of current snapshot
    int getStepCount() { return stepCount; };      ///< get the (sequentially ordered) count of steps executed
    void writeResult();                            ///< write result regardless of runConfig

    // expose raw vectors and operators
    // non-constraint parts
    Teuchos::RCP<TV> getForcePartNonBrown() const { return forcePartNonBrownRcp; }
    Teuchos::RCP<TV> getVelocityPartNonBrown() const { return velocityPartNonBrownRcp; };
    Teuchos::RCP<TV> getVelocityNonBrown() const { return velocityNonBrownRcp; };
    Teuchos::RCP<TV> getVelocityBrown() const { return velocityBrownRcp; };
    Teuchos::RCP<TV> getVelocityNonCon() const { return velocityNonConRcp; };

    // constraint parts
    Teuchos::RCP<const TV> getForceUni() const { return forceUniRcp; };
    Teuchos::RCP<const TV> getVelocityUni() const { return velocityUniRcp; };
    Teuchos::RCP<const TV> getForceBi() const { return forceBiRcp; };
    Teuchos::RCP<const TV> getVelocityBi() const { return velocityBiRcp; };

    // mobility
    Teuchos::RCP<TCMAT> getMobMatrix() { return mobilityMatrixRcp; };
    Teuchos::RCP<TOP> getMobOperator() { return mobilityOperatorRcp; };

    // get information
    /**
     * @brief Get the local and global max gid for particles
     *
     * @return std::pair<int, int> [localMaxGid,globalMaxGid]
     */
    std::pair<int, int> getMaxGid();
};

#endif